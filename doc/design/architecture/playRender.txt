Design: Playback and Render Control
===================================
:Author: Ichthyostega
:Date: 5/2011

//MENU: label Player subsystem

**************************************************************************************
This part of the architecture is concened with how to initiate, coordinate and control
the calculation processes necessary to generate visible / audible data from our source
media. This design is _not so much_ concerned with the actual calculations; indeed it
takes on an ``bird eye's view'', treating the actual render engine mostly just as an
opaque entity providing some service.
**************************************************************************************

Collecting initial drafts
-------------------------

At start of 2011, several design sketches emerged already, as an offspring of other
discussions and brainstorming.

 * the link:/documentation/devel/rfc_pending/EngineInterfaceOverview.html[Engine Interface draft]
   contains some fundamental terms and definitions.
 * discussions regarding time values and timecode handling shed some light onto the requirements
   to be fulfilled by a player subsystem
   
   - link:http://article.gmane.org/gmane.comp.video.lumiera.general/2116[Timecode Widget and Framerates]
   - link:http://article.gmane.org/gmane.comp.video.lumiera.general/2109[Time, Time-spans, Quatisation and Timecode]
   - link:http://lumiera.org/wiki/renderengine.html#TimeQuant[Definition of Time entities]
     from the implementation notes in the TiddlyWiki


Reasoning about the Player Subsystem's structure
------------------------------------------------

At first sight, the name ``Player'' might be surprising. 
The full, complete and precise name would be something along
the lines of ``_render- and playback-process coordination subsystem_''.
Now, we need to shorten that into a single word. The more obvious
abbreviation (just by the importance) would be _Render_, but that
would be strikingly misleading, because everyone would take that
to be the render engine. Which leaves us with _Player_. A second
consideration shows us that the structure of that subsystem will
be very close to the structure of any software player -- the chosen term
turns out to be well aligned with the actual nature of that subsystem.

Influences and Requirements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

In accordance with the spirit of modern software development, the analysis
starts by determining which would be the _Service_ to be provided by such
a player. Consideration of the use cases highlights the fundamental forces
to be _multiplicity_, combined with _differentiation in detail_, all under
the government of _time-bound delivery_, combined with _live reconfiguration_.

The basic service turns out to be *performance of a preconfigured object model*.
This performance is *time based*. Multiple usage instances of this service can
be expected to coexist, each of which can be broken down into a set of *elementary
streams to be delivered synchronously*. The delivery mode can be *reconfigured
on-the-fly*.

Modes of operation
^^^^^^^^^^^^^^^^^^
Delivery can be either _free-wheeling_, so to cover a predefined time interval
with fixed quality calculations (final render), and it can be _throttled_ for using
excess computation power (background rendering). Or -- alternatively -- delivery can
be _time-bound_ (for classical playback), following the projection of wall clock time
onto a predefined timeline interval (the so called ``playhead'' or ``playback cursor''
proceeding along a timeline).

Reconfiguration
^^^^^^^^^^^^^^^
Some of these operation modes need to be prepared to an unpredictable live reconfiguration,
driven by user interactions:

- any part of background rendering can be invalidated and restarted, while other parts
  should be re-integrated, possibly with adjusted position
- the linearly proceeding playback can at any time be

  * paused
  * reversed in direction
  * playback speed adjusted

- the playback can be looped, with _unlimited_ adjustments of the loop boundaries any time.


Resulting Structure
~~~~~~~~~~~~~~~~~~~

After realising these powers, for an experienced developer several building
blocks almost immediately fall into place, that is within the inner vision:

We get instances of a "play/render-me"-service. At the front-end of each of
those instances, there will be a play-controller, which is a "state machine".
It provides states and transitions of the kind "play", "pause", "ffwd", "step",
etc., and can be hooked up with a play-control GUI widget (or something simpler
in case of a render process, which is free wheeling).

Each play-controller in turn gets associated with several play/render-processes,
one for each independent media stream (channel) to be produced. Of course,
each such process is a compound of entries in a registration table, which serve
the purpose of tying several other services together, which we initiate and use
in order to make that render process happen. Most notably, we'll use the
services of the actual engine, which provides us with kind of a "calculation
stream" service, which is capable of delivering a sequence of calculated
data frames in a timely fashion.


And now the point which is important for our discussion here: When a client
requests such an instance of the player service, we build up these parts
providing that service, which cascades down to the individual elements.
At that point, we need to pull and combine two informations:
- the "what" to render: this information stems from the session/model.
- the "how" to render: this information is guided by the output configuration.


Quantisation is a kind of rounding. This is a dangerous and nasty operation.

<irony> the so called "ordinary" people have a completely misguided notion
and a bizarre inclination for rounding. In the pitifully shaded state of their
minds they link it to some kind of cleanliness </irony>

Rounding and quantisation are dangerous, because they kill information content.
Thus there are three fundamental guidelines when it comes to rounding

. don't do it
. do it at most once
. do it as late as possible

These may guide the process of finding the right place for the Quantiser(s) to
apply. We need some information flows to be joined in order to be able to do
the quantisation, which leaves us with just a few possible junction points
where to place quantisation: The backend, the GUI, the player, the session.

- putting it into the backend seems to be the most reasonable at first sight:
  We can "do away" with nasty things soon, especially if they are "technically",
  "get a clean state soon" -- and hasn't frame quantisation something to do
  with media data, which is handled in the backend?
  Well, actually, all of those are pitfalls to trap the unwary. About
  cleanliness, well (sigh). Doing rounding soon will leave us with a huge
  amount of degraded information flows throughout the whole system; thus the
  general rule to do it as late as possible. Uncrippled information is
  enablement. And last but not least: the frame quantisation is connected
  to the /output/ format -- and the backend is likely within the whole
  application the subsytem most remote and unaware of output requirements.
- rounding/quantising in the GUI is extremely common; unfortunately there
  seems to be not a single argument supporting that habit. Most of all,
  it violates the subsidiarity principle.

Which leaves us with the player and the session. Both positions could
arguably be supported. I come to prefering the player mostly out of
gut feeling. In any case there seems to be a remaining tension.

But on a second thought and more careful consideration, the "frame rounding"
can be decomposed in the way I proposed: into the /act of quantisation/
and the /frame grid/. Basically its the session which has the ability
to form the frame grid, but it is lacking crutial information (about
the output). This leads to the proposed approach of a collaboration,
which seems to resolve that tension (at least when considering it
now, from birds eyes view)


